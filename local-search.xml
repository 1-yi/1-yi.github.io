<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>坏了的计算器</title>
    <link href="/2023/10/27/%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <url>/2023/10/27/%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目">题目</h3><p>在显示着数字 <code>startValue</code>的坏计算器上，我们可以执行以下两种操作：</p><ul><li><strong>双倍（Double）：</strong>将显示屏上的数字乘 2；</li><li><strong>递减（Decrement）：</strong>将显示屏上的数字减<code>1</code> 。</li></ul><p>给定两个整数 <code>startValue</code> 和 <code>target</code>。返回显示数字 <code>target</code> 所需的最小操作数。</p><h3 id="示例">示例</h3><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：startValue = <span class="hljs-number">2</span>, target = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：先进行双倍运算，然后再进行递减运算 &#123;<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>&#125;.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：startValue = <span class="hljs-number">5</span>, target = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">2</span><br>解释：先递减，再双倍 &#123;<span class="hljs-number">5</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">8</span>&#125;.<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：startValue = <span class="hljs-number">3</span>, target = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">3</span><br>解释：先双倍，然后递减，再双倍 &#123;<span class="hljs-number">3</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">10</span>&#125;.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= startValue, target &lt;= 109</code></li></ul><h3 id="题解">题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">brokenCalc</span><span class="hljs-params">(<span class="hljs-type">int</span> X, <span class="hljs-type">int</span> Y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (Y &gt; X) &#123;<br>            ans++;<br>            <span class="hljs-keyword">if</span> (Y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>                Y++;<br>            <span class="hljs-keyword">else</span><br>                Y /= <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans + X - Y;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>逆向思维</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可以到达每一个节点的最少边反转次数</title>
    <link href="/2023/09/20/%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%91%E8%BE%B9%E5%8F%8D%E8%BD%AC%E6%AC%A1%E6%95%B0/"/>
    <url>/2023/09/20/%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%91%E8%BE%B9%E5%8F%8D%E8%BD%AC%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目">题目</h3><p>https://leetcode.cn/problems/minimum-edge-reversals-so-every-node-is-reachable/</p><p>给你一个 <code>n</code> 个点的 <strong>简单有向图</strong>（没有重复边的有向图），节点编号为 <code>0</code> 到 <code>n - 1</code>。如果这些边是双向边，那么这个图形成一棵 <strong>树</strong> 。</p><p>给你一个整数 <code>n</code> 和一个 <strong>二维</strong> 整数数组<code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示从节点<code>ui</code> 到节点 <code>vi</code> 有一条 <strong>有向边</strong>。</p><p><strong>边反转</strong> 指的是将一条边的方向反转，也就是说一条从节点<code>ui</code> 到节点 <code>vi</code> 的边会变为一条从节点<code>vi</code> 到节点 <code>ui</code> 的边。</p><p>对于范围 <code>[0, n - 1]</code> 中的每一个节点 <code>i</code>，你的任务是分别 <strong>独立</strong> 计算 <strong>最少</strong>需要多少次 <strong>边反转</strong> ，从节点 <code>i</code> 出发经过<strong>一系列有向边</strong> ，可以到达所有的节点。</p><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>answer</code>，其中 <code>answer[i]</code>表示从节点 <code>i</code>出发，可以到达所有节点的 <strong>最少边反转</strong> 次数。</p><h3 id="题解">题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] minEdgeReversals(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-comment">//******数组list数组 */</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n];<br>        Arrays.setAll(g, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], y = e[<span class="hljs-number">1</span>];<br>            g[x].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;y, <span class="hljs-number">1</span>&#125;);<br>            g[y].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, -<span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// 从 y 到 x 需要反向</span><br>        &#125;<br><br>        <span class="hljs-type">var</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, g, ans);<br>        reroot(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, g, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, List&lt;<span class="hljs-type">int</span>[]&gt;[] g, <span class="hljs-type">int</span>[] ans)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : g[x]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], dir = e[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (y != fa) &#123;<br>                <span class="hljs-keyword">if</span> (dir &lt; <span class="hljs-number">0</span>) &#123;<br>                    ans[<span class="hljs-number">0</span>]++;<br>                &#125;<br>                dfs(y, x, g, ans);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, List&lt;<span class="hljs-type">int</span>[]&gt;[] g, <span class="hljs-type">int</span>[] ans)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : g[x]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], dir = e[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (y != fa) &#123;<br>                ans[y] = ans[x] + dir; <span class="hljs-comment">// dir 就是从 x 换到 y 的「变化量」</span><br>                reroot(y, x, g, ans);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//换根dp</span><br><span class="hljs-comment">//如果这些边是双向边，那么这个图形成一棵树 。    无环......</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳买卖股票时机含冷冻期</title>
    <link href="/2023/05/17/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <url>/2023/05/17/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</p><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code>表示第 <code>*i*</code> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h2 id="示例">示例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [1,2,3,0,2]</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [1]</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//******冷冻期 转2 存在一天</span><br>        dp[<span class="hljs-number">1</span>] =- prices[<span class="hljs-number">0</span>];<span class="hljs-comment">//*****持有股票</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//****不持有股票 转1 可长期存在状态</span><br>        <span class="hljs-type">int</span> tem;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            tem = dp[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//原先持有或买入</span><br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">2</span>] - prices[i]);<br>            <span class="hljs-comment">//冷冻期解除或一直不持有</span><br>            dp[<span class="hljs-number">2</span>] = Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">2</span>]);<br>            <span class="hljs-comment">//卖出股票</span><br>            dp[<span class="hljs-number">0</span>] = tem + prices[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//状态机dp</span><br></code></pre></td></tr></table></figure><p>类似题目</p><p>买卖股票的最佳时机 IV</p><p>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零钱兑换 II</title>
    <link href="/2023/05/16/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/"/>
    <url>/2023/05/16/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目">题目</h3><p>https://leetcode.cn/problems/coin-change-ii/description/</p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数<code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回<code>0</code> 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h3 id="示例">示例</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = 3, coins = [2]<br>输出：0<br>解释：只用面额<span class="hljs-number"> 2 </span>的硬币不能凑成总金额<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：amount </span>=<span class="hljs-string"> 10, coins = [10] </span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><h3 id="题解">题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> coins.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j= <span class="hljs-number">1</span>; j &lt;= amount; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j &gt;= coins[i]) dp[j] += dp[j-coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br><span class="hljs-comment">//***硬币外循环  和内循环  避免排列重复</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文链表</title>
    <link href="/2023/04/23/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/04/23/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>https://leetcode.cn/problems/palindrome-linked-list/description/</p><p>给你一个单链表的头节点 <code>head</code>，请你判断该链表是否为回文链表。如果是，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><h2 id="题解">题解</h2><p>递归解法 dfs中核心算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tem</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(tem != <span class="hljs-literal">null</span>)&#123;<br>            len++;<br>            tem = tem.next;<br>        &#125;<br>         dfs(head, len);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    ListNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> len)</span>&#123;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">if</span>(le n== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> dfs(head.next, len - <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(head.val != tail.val) ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> tail.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样适用于头尾穿插重排数组</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图中的最短环</title>
    <link href="/2023/04/02/%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E7%8E%AF/"/>
    <url>/2023/04/02/%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>现有一个含 <code>n</code> 个顶点的 <strong>双向</strong>图，每个顶点按从 <code>0</code> 到 <code>n - 1</code>标记。图中的边由二维整数数组 <code>edges</code> 表示，其中<code>edges[i] = [ui, vi]</code> 表示顶点 <code>ui</code> 和<code>vi</code>之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p><p>返回图中 <strong>最短</strong> 环的长度。如果不存在环，则返回<code>-1</code> 。</p><p><strong>环</strong>是指以同一节点开始和结束，并且路径中的每条边仅使用一次。</p><h2 id="提示">提示</h2><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= edges.length &lt;= 1000</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ui, vi &lt; n</code></li><li><code>ui != vi</code></li><li>不存在重复的边</li></ul><h2 id="示例">示例</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 7, edges = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,0]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[6,3]</span>]</span><br>输出：3<br>解释：长度最小的循环是：0 -&gt; 1 -&gt; 2 -&gt; 0 <br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">4</span>, edges = <span class="hljs-string">[[0,1],[0,2]]</span><br>输出：<span class="hljs-number">-1</span><br>解释：图中不存在循环<br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findShortestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> edges.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        HashMap&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//************** */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            map.computeIfAbsent(edge[<span class="hljs-number">0</span>], t -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()).add(edge[<span class="hljs-number">1</span>]);<br>            map.computeIfAbsent(edge[<span class="hljs-number">1</span>], t -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()).add(edge[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">//遍历bfs</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            dq.addLast(i);<br>            <span class="hljs-type">int</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">while</span> (!dq.isEmpty())&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> dq.pollFirst();<br>                <span class="hljs-keyword">if</span>(!map.containsKey(num)) <span class="hljs-keyword">continue</span>;<br>                List&lt;Integer&gt; list = map.get(num);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> numm : list)&#123;<br>                    <span class="hljs-keyword">if</span>(dis[numm] == <span class="hljs-number">0</span> &amp;&amp; numm != i) &#123;<br>                        dis[numm] = dis[num] + <span class="hljs-number">1</span>;<br>                        dq.addLast(numm);<br>                    &#125;<br>                    <span class="hljs-comment">//*** 排除上节点情况 */</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis[numm] != dis[num] - <span class="hljs-number">1</span>)&#123;<br>                        ans = Math.min(ans, dis[num] + dis[numm] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质因数</title>
    <link href="/2022/12/18/%E8%B4%A8%E5%9B%A0%E6%95%B0/"/>
    <url>/2022/12/18/%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>质因数之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">SumPrimeFactors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;i * i &lt;= n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(n % i==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>                ans += i;<br>                n /= i;<br>            &#125;<br>        &#125;<br>   &#125;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) ans += n;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计回文子序列数目</title>
    <link href="/2022/11/29/%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/11/29/%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给你数字字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为<code>5</code> 的 <strong>回文子序列</strong>数目。由于答案可能很大，请你将答案对 <code>109 + 7</code><strong>取余</strong> 后返回。</p><p><strong>提示：</strong></p><ul><li>如果一个字符串从前往后和从后往前读相同，那么它是<strong>回文字符串</strong> 。</li><li>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 只包含数字字符。</li></ul><h2 id="示例">示例</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;103301&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>总共有 <span class="hljs-number">6</span> 长度为 <span class="hljs-number">5</span> 的子序列：<span class="hljs-string">&quot;10330&quot;</span> ，<span class="hljs-string">&quot;10331&quot;</span> ，<span class="hljs-string">&quot;10301&quot;</span> ，<span class="hljs-string">&quot;10301&quot;</span> ，<span class="hljs-string">&quot;13301&quot;</span> ，<span class="hljs-string">&quot;03301&quot;</span> 。<br>它们中有两个（都是 <span class="hljs-string">&quot;10301&quot;</span>）是回文的。<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0000000&quot;</span><br>输出：<span class="hljs-number">21</span><br>解释：所有 <span class="hljs-number">21</span> 个长度为 <span class="hljs-number">5</span> 的子序列都是 <span class="hljs-string">&quot;00000&quot;</span> ，都是回文的。<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;9999900000&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：仅有的两个回文子序列是 <span class="hljs-string">&quot;99999&quot;</span> 和 <span class="hljs-string">&quot;00000&quot;</span> 。<br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p><strong>用双前缀和计算 a(0..9) 与 a(0..9)b(0..9)的前缀和，再反向遍历同时实现反方向同类型前缀和与前缀和分段的目的</strong></p><p>首先倒着遍历 s ，统计每个字符的出现次数 suf[a] 和两个字符的组合个数suf2[a][b]</p><p>例如遍历到 a = s[i] 时，就更新 suf2[a][b][0..9] += suf[0..9] ，然后suf[a] 加一。</p><p>然后正着遍历 s，统计每个字符的出现次数 pre[a]和两个字符的组合个数pre2[a][b]，更新方法同上。</p><p>枚举每个 s[i]，当作回文子序列的回文中心，此时的子序列个数就是s[0..i-1] 中的 pre2[a][b] 与 s[i+1..n−1] 中的suf2[a][b]的组合，枚举所有的 a 和 b，个数相乘再相加，即为以 s[i]为回文子序列的回文中心时的答案。</p><p>代码实现时，可以一遍遍历一遍计算 pre2[a][b]，同时撤销suf2[a][b]的统计结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPalindromes</span><span class="hljs-params">(String S)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> S.toCharArray();<br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>], suf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[][] pre2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>], suf2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; ++j)<br>                suf2[d][j] += suf[j];<br>            ++suf[d];<br>        &#125;<br><br>        <span class="hljs-type">var</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> d : s) &#123;<br>            d -= <span class="hljs-string">&#x27;0&#x27;</span>;<br>            --suf[d];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; ++j)<br>                suf2[d][j] -= suf[j]; <span class="hljs-comment">// 撤销</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; ++j)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; ++k)<br>                    ans += (<span class="hljs-type">long</span>) pre2[j][k] * suf2[j][k]; <span class="hljs-comment">// 枚举所有字符组合</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; ++j)<br>                pre2[d][j] += pre[j];<br>            ++pre[d];<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (ans % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从链表中移除节点</title>
    <link href="/2022/11/29/%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/"/>
    <url>/2022/11/29/%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/"class="uri">https://leetcode.cn/problems/remove-nodes-from-linked-list/</a></p><p>给你一个链表的头节点 head 。</p><p>对于列表中的每个节点 node ，如果其右侧存在一个具有 严格更大值的节点，则移除 node 。</p><p>返回修改后链表的头节点 head 。</p><h2 id="示例">示例</h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：head = [5,2,13,3,8]<br>输出：[13,8]<br>解释：需要移除的节点是<span class="hljs-number"> 5 </span>，2 和<span class="hljs-number"> 3 </span>。<br>- 节点<span class="hljs-number"> 13 </span>在节点<span class="hljs-number"> 5 </span>右侧。<br>- 节点<span class="hljs-number"> 13 </span>在节点<span class="hljs-number"> 2 </span>右侧。<br>- 节点<span class="hljs-number"> 8 </span>在节点<span class="hljs-number"> 3 </span>右侧。<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,1,1,1</span>]<br>输出：[<span class="hljs-number">1,1,1,1</span>]<br>解释：每个节点的值都是 <span class="hljs-number">1</span> ，所以没有需要移除的节点。<br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>典型递归题型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNodes</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        head.next = removeNodes(head.next);<br>        <span class="hljs-keyword">if</span>(head.val &lt; head.next.val) <span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提取数据单调栈也可以</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间子数组个数</title>
    <link href="/2022/11/24/%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/11/24/%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><ahref="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/"class="uri">https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/</a></p><p>给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums中连续、非空且其中最大元素在范围 [left, right]内的子数组，并返回满足条件的子数组的个数。</p><p>生成的测试用例保证结果符合 32-bit 整数范围。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li><li><code>0 &lt;= left &lt;= right &lt;= 109</code></li></ul><h2 id="示例">示例</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,1,4,3]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：满足条件的三个子数组：<span class="hljs-selector-attr">[2]</span>, <span class="hljs-selector-attr">[2, 1]</span>, <span class="hljs-selector-attr">[3]</span><br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-built_in">left</span> = <span class="hljs-number">2</span>, <span class="hljs-built_in">right</span> = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>统计所有最大值范围在 [a, b][a,b]之间的子数组个数，可等价为统计每一个范围落在 [a, b][a,b] 之间的 nums[i]作为最大值时子数组的个数。</p><p>由此可以进一步将问题转换为：求解每个 nums[i]作为子数组最大值时，最远的合法左右端点的位置。这可以使用「单调栈」来进行求解。</p><p>即 (r - i) * (i - l)</p><p>统计所有 nums[i] 对答案的贡献即是最终答案，但我们忽略了「当 nums存在重复元素，且该元素作为子数组最大值时，最远左右端点的边界越过重复元素时，导致重复统计子数组」的问题。为了消除这种重复统计，我们可以将「最远左右边界」的一端，从「严格小于」调整为「小于等于」，从而实现半开半闭的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>], r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        Arrays.fill(l, -<span class="hljs-number">1</span>); Arrays.fill(r, n);<br>        Deque&lt;Integer&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!d.isEmpty() &amp;&amp; nums[d.peekLast()] &lt; nums[i]) r[d.pollLast()] = i;<br>            d.addLast(i);<br>        &#125;<br>        d.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!d.isEmpty() &amp;&amp; nums[d.peekLast()] &lt;= nums[i]) l[d.pollLast()] = i;<br>            d.addLast(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; a || nums[i] &gt; b) <span class="hljs-keyword">continue</span>;<br>            ans += (i - l[i]) * (r[i] - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解-模拟">题解 模拟</h2><p>从小到大枚举数组右端点，同时维护上一个值 &gt; right 的元素下标 i0和上一个值在 [left,right] 内的元素下标 i1，则该右端点对应的左端点个数为i1 - i0，累加个数， 得到答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, ans = <span class="hljs-number">0</span>, i0 = -<span class="hljs-number">1</span>, i1 = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; right) i0 = i;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= left) i1 = i;<br>            ans += i1 - i0;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>子数组</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第N个神奇数字</title>
    <link href="/2022/11/22/%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/"/>
    <url>/2022/11/22/%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/nth-magical-number/"class="uri">https://leetcode.cn/problems/nth-magical-number/</a></p><p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p><p>给定三个整数 n , a , b ，返回第 n个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模后的值。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 109</code></li><li><code>2 &lt;= a, b &lt;= 4 * 104</code></li></ul><h2 id="示例">示例</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>二分答案逆推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthMagicalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.min(a,b);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> l * n;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> a * b / gcd(a,b);<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> mid / a + mid / b;<br>                t -= mid / mc;<br>                <span class="hljs-keyword">if</span>(t &lt; n) l = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> r = mid;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(l % MOD);<br>    &#125;<br>    <span class="hljs-type">int</span>  <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> gcd(b,a % b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大公约数</title>
    <link href="/2022/11/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <url>/2022/11/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>辗转相除法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>  <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> gcd(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><ahref="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/"class="uri">https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/</a></p><p>给定一个二维网格 <code>grid</code> ，其中：</p><ul><li>'.' 代表一个空房间</li><li>'#' 代表一堵</li><li>'@' 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙/锁 的个数，且满足<code>1 &lt;= k &lt;= 6</code>，字母表中的前 <code>k</code>个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回<code>-1</code> 。</p><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 30</code></li><li><code>grid[i][j]</code> 只含有 <code>'.'</code>, <code>'#'</code>,<code>'@'</code>, <code>'a'-``'f``'</code> 以及<code>'A'-'F'</code></li><li>钥匙的数目范围是 <code>[1, 6]</code></li><li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li><li>每个钥匙正好打开一个对应的锁</li></ul><h2 id="示例">示例</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@..aA&quot;</span>,<span class="hljs-string">&quot;..B#.&quot;</span>,<span class="hljs-string">&quot;....b&quot;</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: grid = [&quot;@Aa&quot;]</span><br><span class="hljs-section">输出: -1</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>重复搜索，选择BFS而非DFS</p><p>使用一个 <code>int</code> 类型二进制数 <code>state</code>来代指当前收集到钥匙情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">35</span>, K = <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N][<span class="hljs-number">1</span> &lt;&lt; K];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathAllKeys</span><span class="hljs-params">(String[] g)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length, m = g[<span class="hljs-number">0</span>].length(), cnt = <span class="hljs-number">0</span>;<br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                Arrays.fill(dist[i][j], INF);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[i].charAt(j);<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;@&#x27;</span>) &#123;<br>                    d.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, <span class="hljs-number">0</span>&#125;);<br>                    dist[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!d.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] info = d.pollFirst();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">0</span>], y = info[<span class="hljs-number">1</span>], cur = info[<span class="hljs-number">2</span>], step = dist[x][y][cur];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] di : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + di[<span class="hljs-number">0</span>], ny = y + di[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[nx].charAt(ny);<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &amp;&amp; (cur &gt;&gt; (c - <span class="hljs-string">&#x27;A&#x27;</span>) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ncur</span> <span class="hljs-operator">=</span> cur;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) ncur |= <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (ncur == (<span class="hljs-number">1</span> &lt;&lt; cnt) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (step + <span class="hljs-number">1</span> &gt;= dist[nx][ny][ncur]) <span class="hljs-keyword">continue</span>;<br>                dist[nx][ny][ncur] = step + <span class="hljs-number">1</span>;<br>                d.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny, ncur&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大加号标志</title>
    <link href="/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/"/>
    <url>/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/largest-plus-sign/description/"class="uri">https://leetcode.cn/problems/largest-plus-sign/description/</a></p><p>在一个 <code>n x n</code> 的矩阵 <code>grid</code> 中，除了在数组<code>mines</code> 中给出的元素为 <code>0</code>，其他每个元素都为<code>1</code>。<code>mines[i] = [xi, yi]</code>表示<code>grid[xi][yi] == 0</code></p><p>返回 <code>grid</code> <em>中包含 <code>1</code> 的最大的<strong>轴对齐</strong> 加号标志的阶数</em> 。如果未找到加号标志，则返回<code>0</code> 。</p><p>一个 <code>k</code> 阶由 <em><code>1</code></em> 组成的<strong>“轴对称”加号标志</strong> 具有中心网格<code>grid[r][c] == 1</code>，以及4个从中心向上、向下、向左、向右延伸，长度为 <code>k-1</code>，由<code>1</code> 组成的臂。注意，只有加号标志的所有网格要求为<code>1</code> ，别的网格可能为 <code>0</code> 也可能为 <code>1</code>。</p><h2 id="示例">示例</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: n = <span class="hljs-number">5</span>, mines = <span class="hljs-string">[[4, 2]]</span><br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: n = <span class="hljs-number">1</span>, mines = <span class="hljs-string">[[0, 0]]</span><br>输出: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>预处理四个方向最长长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orderOfLargestPlusSign</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] mines)</span> &#123;<br>        <span class="hljs-type">int</span>[][] grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) Arrays.fill(grid[i], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] mm : mines)&#123;<br>            grid[mm[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>][mm[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//四个方向</span><br>        <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    a[i][j] = a[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>                    b[i][j] = b[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (grid[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j] == <span class="hljs-number">1</span>) &#123;<br>                    c[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j] = c[n + <span class="hljs-number">2</span> - i][n + <span class="hljs-number">1</span> - j] + <span class="hljs-number">1</span>;<br>                    d[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j] = d[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">2</span> - j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                ans = Math.max(ans, Math.min(Math.min(a[i][j], b[i][j]), Math.min(c[i][j], d[i][j])));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小移动总距离</title>
    <link href="/2022/11/07/%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/11/07/%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><ahref="https://leetcode.cn/problems/minimum-total-distance-traveled/description/"class="uri">https://leetcode.cn/problems/minimum-total-distance-traveled/description/</a></p><p>X 轴上有一些机器人和工厂。给你一个整数数组 <code>robot</code> ，其中<code>robot[i]</code> 是第 <code>i</code>个机器人的位置。再给你一个二维整数数组 <code>factory</code> ，其中<code>factory[j] = [positionj, limitj]</code> ，表示第 <code>j</code>个工厂的位置在 <code>positionj</code> ，且第 <code>j</code>个工厂最多可以修理 <code>limitj</code> 个机器人。</p><p>每个机器人所在的位置 <strong>互不相同</strong> 。每个工厂所在的位置也<strong>互不相同</strong> 。注意一个机器人可能一开始跟一个工厂在<strong>相同的位置</strong> 。</p><p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是X 轴的正方向，要么是 X轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p><p><strong>任何时刻</strong>，你都可以设置 <strong>部分</strong>机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p><p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p><p><strong>注意：</strong></p><ul><li>所有机器人移动速度相同。</li><li>如果两个机器人移动方向相同，它们永远不会碰撞。</li><li>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。</li><li>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。</li><li>机器人从位置 <code>x</code> 到位置 <code>y</code> 的移动距离为<code>|y - x|</code> 。</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li><li><code>factory[j].length == 2</code></li><li><code>-109 &lt;= robot[i], positionj &lt;= 109</code></li><li><code>0 &lt;= limitj &lt;= robot.length</code></li><li>测试数据保证所有机器人都可以被维修。</li></ul><h2 id="示例">示例</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：robot = [<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>], factory = <span class="hljs-string">[[2,2],[6,2]]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：robot = [<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>], factory = <span class="hljs-string">[[-2,1],[2,1]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>设最优方案中，机器人 <code>i</code> 被送去工厂 <code>Ti</code>，存在最优方案，使得<code>Ti</code>是不严格单调递增的。</p><p>定义 <code>dp[i][j]</code>表示前 <code>i</code>个工厂修复前<code>j</code>个机器人的最小移动总距离。考虑去最后一个工厂的机器人有多少个，可以得到动态规划转移方程：</p><p><span class="math display">\[d p[i][j]=\min _{k=0}^{\min \left(\text { limiti }_{i} j\right)}\left(dp[i-1][j-k]+\sum_{l=0}^{k-1} \mid \operatorname{robot}[j-l]-\text {position }_{i} \mid\right)\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> robot.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> factory.length;<br>        Collections.sort(robot);<br>        Arrays.sort(factory);<br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//工厂为0 不能匹配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0x3f3f3f3f3f3f3f3fL</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n ; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> factory[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lim</span> <span class="hljs-operator">=</span> factory[j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//初始值 0个机器人到 j 工厂</span><br>                dp[i][j] = dp[i][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//累加距离减少一次遍历</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &gt;= Math.max(<span class="hljs-number">1</span> , i - lim + <span class="hljs-number">1</span>); k--)&#123;<br>                    sum += Math.abs(pos-robot.get(k - <span class="hljs-number">1</span>));<br>                    dp[i][j] = Math.min(dp[i][j], dp[k - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
