<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第N个神奇数字</title>
    <link href="/2022/11/22/%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/"/>
    <url>/2022/11/22/%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/nth-magical-number/"class="uri">https://leetcode.cn/problems/nth-magical-number/</a></p><p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p><p>给定三个整数 n , a , b ，返回第 n个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模后的值。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 109</code></li><li><code>2 &lt;= a, b &lt;= 4 * 104</code></li></ul><h2 id="示例">示例</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>二分答案逆推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthMagicalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.min(a,b);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> l * n;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> a * b / gcd(a,b);<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> mid / a + mid / b;<br>                t -= mid / mc;<br>                <span class="hljs-keyword">if</span>(t &lt; n) l = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> r = mid;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(l % MOD);<br>    &#125;<br>    <span class="hljs-type">int</span>  <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> gcd(b,a % b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大公约数</title>
    <link href="/2022/11/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <url>/2022/11/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>辗转相除法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>  <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> gcd(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><ahref="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/"class="uri">https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/</a></p><p>给定一个二维网格 <code>grid</code> ，其中：</p><ul><li>'.' 代表一个空房间</li><li>'#' 代表一堵</li><li>'@' 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙/锁 的个数，且满足<code>1 &lt;= k &lt;= 6</code>，字母表中的前 <code>k</code>个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回<code>-1</code> 。</p><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 30</code></li><li><code>grid[i][j]</code> 只含有 <code>'.'</code>, <code>'#'</code>,<code>'@'</code>, <code>'a'-``'f``'</code> 以及<code>'A'-'F'</code></li><li>钥匙的数目范围是 <code>[1, 6]</code></li><li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li><li>每个钥匙正好打开一个对应的锁</li></ul><h2 id="示例">示例</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@..aA&quot;</span>,<span class="hljs-string">&quot;..B#.&quot;</span>,<span class="hljs-string">&quot;....b&quot;</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: grid = [&quot;@Aa&quot;]</span><br><span class="hljs-section">输出: -1</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>重复搜索，选择BFS而非DFS</p><p>使用一个 <code>int</code> 类型二进制数 <code>state</code>来代指当前收集到钥匙情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">35</span>, K = <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N][<span class="hljs-number">1</span> &lt;&lt; K];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathAllKeys</span><span class="hljs-params">(String[] g)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length, m = g[<span class="hljs-number">0</span>].length(), cnt = <span class="hljs-number">0</span>;<br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                Arrays.fill(dist[i][j], INF);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[i].charAt(j);<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;@&#x27;</span>) &#123;<br>                    d.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, <span class="hljs-number">0</span>&#125;);<br>                    dist[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!d.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] info = d.pollFirst();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">0</span>], y = info[<span class="hljs-number">1</span>], cur = info[<span class="hljs-number">2</span>], step = dist[x][y][cur];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] di : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + di[<span class="hljs-number">0</span>], ny = y + di[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[nx].charAt(ny);<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &amp;&amp; (cur &gt;&gt; (c - <span class="hljs-string">&#x27;A&#x27;</span>) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ncur</span> <span class="hljs-operator">=</span> cur;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) ncur |= <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (ncur == (<span class="hljs-number">1</span> &lt;&lt; cnt) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (step + <span class="hljs-number">1</span> &gt;= dist[nx][ny][ncur]) <span class="hljs-keyword">continue</span>;<br>                dist[nx][ny][ncur] = step + <span class="hljs-number">1</span>;<br>                d.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny, ncur&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大加号标志</title>
    <link href="/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/"/>
    <url>/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/largest-plus-sign/description/"class="uri">https://leetcode.cn/problems/largest-plus-sign/description/</a></p><p>在一个 <code>n x n</code> 的矩阵 <code>grid</code> 中，除了在数组<code>mines</code> 中给出的元素为 <code>0</code>，其他每个元素都为<code>1</code>。<code>mines[i] = [xi, yi]</code>表示<code>grid[xi][yi] == 0</code></p><p>返回 <code>grid</code> <em>中包含 <code>1</code> 的最大的<strong>轴对齐</strong> 加号标志的阶数</em> 。如果未找到加号标志，则返回<code>0</code> 。</p><p>一个 <code>k</code> 阶由 <em><code>1</code></em> 组成的<strong>“轴对称”加号标志</strong> 具有中心网格<code>grid[r][c] == 1</code>，以及4个从中心向上、向下、向左、向右延伸，长度为 <code>k-1</code>，由<code>1</code> 组成的臂。注意，只有加号标志的所有网格要求为<code>1</code> ，别的网格可能为 <code>0</code> 也可能为 <code>1</code>。</p><h2 id="示例">示例</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: n = <span class="hljs-number">5</span>, mines = <span class="hljs-string">[[4, 2]]</span><br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: n = <span class="hljs-number">1</span>, mines = <span class="hljs-string">[[0, 0]]</span><br>输出: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>预处理四个方向最长长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orderOfLargestPlusSign</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] mines)</span> &#123;<br>        <span class="hljs-type">int</span>[][] grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) Arrays.fill(grid[i], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] mm : mines)&#123;<br>            grid[mm[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>][mm[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//四个方向</span><br>        <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    a[i][j] = a[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>                    b[i][j] = b[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (grid[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j] == <span class="hljs-number">1</span>) &#123;<br>                    c[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j] = c[n + <span class="hljs-number">2</span> - i][n + <span class="hljs-number">1</span> - j] + <span class="hljs-number">1</span>;<br>                    d[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j] = d[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">2</span> - j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                ans = Math.max(ans, Math.min(Math.min(a[i][j], b[i][j]), Math.min(c[i][j], d[i][j])));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小移动总距离</title>
    <link href="/2022/11/07/%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/11/07/%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><ahref="https://leetcode.cn/problems/minimum-total-distance-traveled/description/"class="uri">https://leetcode.cn/problems/minimum-total-distance-traveled/description/</a></p><p>X 轴上有一些机器人和工厂。给你一个整数数组 <code>robot</code> ，其中<code>robot[i]</code> 是第 <code>i</code>个机器人的位置。再给你一个二维整数数组 <code>factory</code> ，其中<code>factory[j] = [positionj, limitj]</code> ，表示第 <code>j</code>个工厂的位置在 <code>positionj</code> ，且第 <code>j</code>个工厂最多可以修理 <code>limitj</code> 个机器人。</p><p>每个机器人所在的位置 <strong>互不相同</strong> 。每个工厂所在的位置也<strong>互不相同</strong> 。注意一个机器人可能一开始跟一个工厂在<strong>相同的位置</strong> 。</p><p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是X 轴的正方向，要么是 X轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p><p><strong>任何时刻</strong>，你都可以设置 <strong>部分</strong>机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p><p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p><p><strong>注意：</strong></p><ul><li>所有机器人移动速度相同。</li><li>如果两个机器人移动方向相同，它们永远不会碰撞。</li><li>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。</li><li>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。</li><li>机器人从位置 <code>x</code> 到位置 <code>y</code> 的移动距离为<code>|y - x|</code> 。</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li><li><code>factory[j].length == 2</code></li><li><code>-109 &lt;= robot[i], positionj &lt;= 109</code></li><li><code>0 &lt;= limitj &lt;= robot.length</code></li><li>测试数据保证所有机器人都可以被维修。</li></ul><h2 id="示例">示例</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：robot = [<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>], factory = <span class="hljs-string">[[2,2],[6,2]]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：robot = [<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>], factory = <span class="hljs-string">[[-2,1],[2,1]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>设最优方案中，机器人 <code>i</code> 被送去工厂 <code>Ti</code>，存在最优方案，使得<code>Ti</code>是不严格单调递增的。</p><p>定义 <code>dp[i][j]</code>表示前 <code>i</code>个工厂修复前<code>j</code>个机器人的最小移动总距离。考虑去最后一个工厂的机器人有多少个，可以得到动态规划转移方程：</p><p><span class="math display">\[d p[i][j]=\min _{k=0}^{\min \left(\text { limiti }_{i} j\right)}\left(dp[i-1][j-k]+\sum_{l=0}^{k-1} \mid \operatorname{robot}[j-l]-\text {position }_{i} \mid\right)\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> robot.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> factory.length;<br>        Collections.sort(robot);<br>        Arrays.sort(factory);<br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//工厂为0 不能匹配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0x3f3f3f3f3f3f3f3fL</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n ; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> factory[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lim</span> <span class="hljs-operator">=</span> factory[j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//初始值 0个机器人到 j 工厂</span><br>                dp[i][j] = dp[i][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//累加距离减少一次遍历</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &gt;= Math.max(<span class="hljs-number">1</span> , i - lim + <span class="hljs-number">1</span>); k--)&#123;<br>                    sum += Math.abs(pos-robot.get(k - <span class="hljs-number">1</span>));<br>                    dp[i][j] = Math.min(dp[i][j], dp[k - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
